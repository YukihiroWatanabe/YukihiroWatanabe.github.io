
<!--
******************************************************
Nakano-style Associatron
Cue → Context competition → Spark → Recall

2026/01/22

C-side Laboratory, Yatsugatake
Yukihiro Watanabe
******************************************************

Goal:
  Give the system an "external time axis" (era rooms), like humans do.
  Use a cue (smell + extra conditions) to narrow rooms,
  then let memories compete across rooms so a distant recall can rise up.

  - Learn: append into the selected room, reinforce similar, forget unused
  - Recall: independent from the write target
            cue -> Top2 rooms -> memory competition -> winner recall
  - Spark: visualize overlap inside the winner room (more burn = more overlap)

Notes:
  - No 4096x4096 full matrix (uses low-rank style mixing)
  - Full version assumes Python/C integration; this is a lightweight demo

------------------------------------------------------
Autonomy Demonstration Notes (technical)

Camera input is treated as a perturbation (initial condition), not a command.

External signal → sparse cue injection → context competition (room selection)
               → memory competition → attractor convergence

The external signal does not specify:
  - which room must win
  - which memory must be recalled
  - what final pattern must appear

A recalled state emerges from internal dynamics (competition + convergence).
This is distinct from reactive control (input → policy → action)
and distinct from prompt-driven generation (prompt → next-token prediction).

The external world can trigger the process,
while the system determines its internal trajectory.
------------------------------------------------------

******************************************************
-->

<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Nakano-style Associatron (Cue Rooms Demo)</title>
  <style>
    :root { color-scheme: dark; }
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, sans-serif; background:#0b0f14; color:#e8eef5; }
    header { padding:12px 14px; border-bottom:1px solid rgba(255,255,255,.08); }
    h1 { font-size:16px; margin:0; }
    .sub { font-size:12px; opacity:.82; line-height:1.45; }

    .wrap { display:grid; grid-template-columns: 380px 1fr; gap:12px; padding:12px; align-items:start; }

    .card { background: rgba(255,255,255,.04); border:1px solid rgba(255,255,255,.08); border-radius:14px; padding:12px; }

    .row { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    button { background: rgba(255,255,255,.08); border:1px solid rgba(255,255,255,.12); color:#e8eef5;
             padding:8px 10px; border-radius:10px; cursor:pointer; }
    button:hover { background: rgba(255,255,255,.12); }
    button.primary { background: rgba(180,220,255,.22); border-color: rgba(180,220,255,.35); }
    button.primary:hover { background: rgba(180,220,255,.30); }

    .label { font-size:12px; opacity:.88; }
    .small { font-size:11px; opacity:.76; }
    .pill { font-size:11px; padding:3px 7px; border-radius:999px; background: rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.10); }

    input[type="range"] { width: 220px; }

    /* --- canvas base --- */
    canvas {
      background: #0a111a;
      border-radius: 12px;
    }

    /* input canvas: pale pink border */
    .canvasInput {
      border: 1px solid rgba(255, 160, 190, 0.45);
      box-shadow: 0 0 0 1px rgba(255, 160, 190, 0.12) inset;
    }

    /* output canvas: pale gray border */
    .canvasOutput {
      border: 1px solid rgba(255, 255, 255, 0.14);
      box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.06) inset;
    }

    .gridRight {
     display:grid;
     grid-template-rows: auto auto;
     gap:12px;
    }
    .grid3 { display:grid; grid-template-columns: 1fr 1fr 1fr; gap:12px; }

    .rooms { display:flex; flex-direction:column; gap:10px; margin-top:6px; }
    .roomline { display:flex; align-items:center; gap:10px; }
    .roomname { width: 92px; font-size:12px; opacity:.9; }
    .bar { width: 250px; height: 10px; background: rgba(255,255,255,.06); border-radius: 999px; overflow:hidden; border:1px solid rgba(255,255,255,.10); }
    .bar > div { height:100%; width:0%; background: rgba(180,220,255,.9); }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size:11px; opacity:.85; white-space: pre-wrap; }

    .radioGroup { display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    .radioItem {
      display:flex; gap:6px; align-items:center;
      padding:6px 8px; border-radius:10px;
      background: rgba(255,255,255,.04);
      border: 1px solid rgba(255,255,255,.08);
    }
    .radioItem input { transform: translateY(1px); }

    .hint { font-size:11px; opacity:.75; margin-top:4px; line-height:1.35; }

    /* ---------- layout upgrade: top-right canvas + info ---------- */
    .topCue {
      display: grid;
      grid-template-columns: 256px 1fr;
      gap: 12px;
      align-items: start;
    }
    .infoPanel {
      min-height: 256px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    .bigStatus {
      font-size: 13px;
      line-height: 1.6;
      opacity: .95;
    }
    .bigMono {
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      font-size: 12px;
      line-height: 1.55;
      opacity: .90;
      white-space: pre-wrap;
    }
    .episodeBox {
      padding: 10px;
      border-radius: 12px;
      background: rgba(255,255,255,.03);
      border: 1px solid rgba(255,255,255,.08);
    }

    /* optional: keep the top-right readable on narrow screens */
    @media (max-width: 980px){
      .wrap { grid-template-columns: 1fr; }
      .topCue { grid-template-columns: 256px 1fr; }
    }
    @media (max-width: 560px){
      .topCue { grid-template-columns: 1fr; }
    }

    /* ---------- camera mini bar (top-right header area) ---------- */
    .camBar {
      display:flex;
      align-items:center;
      gap:8px;
      flex-wrap:wrap;
      padding:8px 10px;
      border-radius:12px;
      background: rgba(255,255,255,.03);
      border: 1px solid rgba(255,255,255,.08);
    }
    .camBar .label { opacity:.85; }
    .camBar button {
      padding:6px 8px;
      border-radius:10px;
      font-size:12px;
    }
    .camBar select {
      padding:6px 8px;
      border-radius:10px;
      background: rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.12);
      color:#e8eef5;
      outline:none;
      font-size:12px;
      max-width: 220px;
    }
    .camBar input[type="range"]{
      width: 140px;
    }
    .camTiny {
      font-size:11px;
      opacity:.78;
    }

    /* hidden video elements (used for processing, not layout) */
    #webcam {
      position: absolute;
      left: -99999px;
      top: -99999px;
      width: 256px;
      height: 256px;
      opacity: 0;
      pointer-events: none;
    }
    #overlayCanvas {
      position: absolute;
      left: -99999px;
      top: -99999px;
      width: 256px;
      height: 256px;
      opacity: 0;
      pointer-events: none;
    }
  </style>
</head>

<body>
<header>
  <h1>Cue → Competition → Spark → Recall  •  Nakano-style Associatron (associative memory dynamics)</h1>
</header>

<div class="wrap">
  <!-- Left -->
  <div class="card">
    <div class="row" style="justify-content:space-between;">
      <div class="label">Cue</div>
      <div class="pill">N = 64×64 = 4096</div>
    </div>

    <div class="row" style="margin-top:10px;">
      <button id="btnClear">Clear Cue</button>
      <button id="btnNoise">Add Noise</button>
      <button id="btnRecall" class="primary">Recall (Run)</button>
    </div>

    <!-- write room: RADIO -->
    <div style="margin-top:14px;" class="label">Episode Age (Write Target)</div>
    <div class="radioGroup" id="writeRadios" style="margin-top:6px;"></div>

    <div class="row" style="margin-top:10px;">
      <button id="btnLearn" class="primary">Store Trace (Learn)</button>
      <button id="btnForgetRoom">Reset This Room</button>
      <button id="btnForgetAll">Reset All Memory</button>
      <span id="txtWriteRoom" class="pill">Overwrite Mode (Strong Write)</span>
      <span id="txtLearnInfo" class="pill">P=0</span>
    </div>

    <div class="hint">
      Flow:<br/>
      1) Choose target → 2) Draw cue → 3) Store trace (repeat to strengthen)<br/>
      Clear cue → Recall runs across rooms (write target is for learning, not recall)
    </div>

    <!-- smell -->
    <div class="row" style="margin-top:14px;">
      <div class="label">Cue Channel: Smell</div>
      <button id="btnSmellToggle">OFF (disabled)</button>
      <div class="label small">Strength (cue weight)</div>
      <input id="rngSmell" type="range" min="0" max="1" step="0.01" value="0.75"/>
      <span id="txtSmell" class="mono">0.75</span>
      <span id="txtCoverage" class="pill">gate 0.0% / mem 0.0%</span>
    </div>

    <div class="row" style="margin-top:8px;">
      <div class="label">Door threshold θ</div>
      <input id="rngTheta" type="range" min="-0.2" max="0.9" step="0.01" value="0.28"/>
      <span id="txtTheta" class="mono">0.28</span>
      <div class="label small">Hesitation Δ</div>
      <input id="rngDelta" type="range" min="0" max="0.6" step="0.01" value="0.10"/>
      <span id="txtDelta" class="mono">0.10</span>
    </div>

    <div class="row" style="margin-top:8px;">
      <div class="label">Display β</div>
      <input id="rngBeta" type="range" min="1" max="30" step="1" value="12"/>
      <span id="txtBeta" class="mono">12</span>
      <span id="txtTopRooms" class="pill">Top: -</span>
    </div>

    <div style="margin-top:12px;" class="label">Hallway (room opening likelihood)</div>
    <div class="rooms" id="roomsBox"></div>
  </div>

  <!-- Right -->
  <div class="card">
    <div class="gridRight">

      <!-- Input (top-right): canvas + info -->
      <div class="topCue">
        <!-- left: canvas -->
        <div>
          <div class="label">Draw Cue</div>
          <canvas id="cvGym" class="canvasInput" width="256" height="256"></canvas>
          <div class="small" style="margin-top:6px;">Draw a partial cue. Add noise to test basin robustness.</div>
        </div>

        <!-- right: moved sub + status + episode -->
        <div class="infoPanel">

          <!-- camera mini controls (top-right header area) -->
          <div class="camBar">
            <span class="label">Camera</span>
            <button id="btnStartCam">Start</button>
            <button id="btnStopCam">Stop</button>

            <select id="selCamera" title="Camera device">
              <option value="">Default camera</option>
            </select>

            <span class="label">Exposure</span>
            <input id="rngExposure" type="range" min="0.60" max="1.60" step="0.01" value="1.00"/>
            <span id="txtExposure" class="mono">1.00</span>

            <span id="txtCamState" class="pill">OFF</span>

            <span class="camTiny">finger → cue line → stop → auto recall</span>
          </div>

          <!-- hidden processing elements (not layout) -->
          <video id="webcam" autoplay playsinline muted></video>
          <canvas id="overlayCanvas" width="256" height="256"></canvas>

          <div class="sub">
            - Learning stores traces (reinforce similar, forget over time).<br/>
            - Recall is not lookup: a cue activates candidates, they compete, and one basin wins.<br/>
            - Spark reveals overlap inside the winning basin: shared structure becomes visible.
          </div>

          <div>
            <div class="label">State</div>
            <div id="txtStatus" class="bigStatus" style="margin-top:4px;"></div>
            <div id="txtDebug" class="bigMono" style="margin-top:8px;"></div>
          </div>

          <div>
            <div class="label">Episode traces (stored memories)</div>
            <div id="txtEpisode" class="bigStatus episodeBox">Door is still closed.</div>
          </div>

        </div>
      </div>

      <!-- 3 panels (bottom-right) -->
      <div class="grid3">
        <div>
          <div class="label">Tatami (8×8): place lights first</div>
          <canvas id="cvTatami" class="canvasOutput" width="256" height="256"></canvas>
          <div class="small" style="margin-top:6px;">
            - When the door opens, “place” comes first.<br/>
            - If the cue is vague, the light spreads.
          </div>
        </div>

        <div>
          <div class="label">Spark: Shared Features Ignite</div>
          <canvas id="cvSpark"  class="canvasOutput" width="256" height="256"></canvas>
          <div class="small" style="margin-top:6px;">
            - Winner-room memories are stacked, weighted by cue similarity.<br/>
            - Hotter means “more shared here.”
          </div>
        </div>

        <div>
          <div class="label">Recalled Pattern (64×64)</div>
          <canvas id="cvRecall" class="canvasOutput" width="256" height="256"></canvas>
          <div class="small" style="margin-top:6px;">
            - Recall runs using the final winner memory (across rooms).<br/>
            - Low-rank mixing (fast).
          </div>
        </div>
      </div>

    </div>
  </div>

</div>

<script>
(function(){
  // ---------- utils ----------
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const sigmoid = (x)=>1/(1+Math.exp(-x));

  // ---------- dims ----------
  const W = 64, H = 64, N = W*H;
  const TW = 8, TH = 8, TN = TW*TH;

  // ---------- DOM ----------
  const cvGym = document.getElementById('cvGym');
  const cxGym = cvGym.getContext('2d');
  const cvRecall = document.getElementById('cvRecall');
  const cxRecall = cvRecall.getContext('2d');
  const cvTatami = document.getElementById('cvTatami');
  const cxTatami = cvTatami.getContext('2d');
  const cvSpark = document.getElementById('cvSpark');
  const cxSpark = cvSpark.getContext('2d');

  const btnClear = document.getElementById('btnClear');
  const btnNoise = document.getElementById('btnNoise');
  const btnRecall = document.getElementById('btnRecall');
  const btnLearn  = document.getElementById('btnLearn');
  const btnForgetRoom = document.getElementById('btnForgetRoom');
  const btnForgetAll  = document.getElementById('btnForgetAll');

  const btnSmellToggle = document.getElementById('btnSmellToggle');
  const rngSmell = document.getElementById('rngSmell');
  const txtSmell = document.getElementById('txtSmell');
  const rngTheta = document.getElementById('rngTheta');
  const txtTheta = document.getElementById('txtTheta');
  const rngDelta = document.getElementById('rngDelta');
  const txtDelta = document.getElementById('txtDelta');
  const rngBeta = document.getElementById('rngBeta');
  const txtBeta = document.getElementById('txtBeta');

  const roomsBox = document.getElementById('roomsBox');
  const txtStatus = document.getElementById('txtStatus');
  const txtDebug = document.getElementById('txtDebug');
  const txtEpisode = document.getElementById('txtEpisode');
  const txtWriteRoom = document.getElementById('txtWriteRoom');
  const txtLearnInfo = document.getElementById('txtLearnInfo');
  const txtCoverage = document.getElementById('txtCoverage');
  const txtTopRooms = document.getElementById('txtTopRooms');

  const writeRadios = document.getElementById('writeRadios');

  // ---------- state vectors ----------
  const xGym    = new Float32Array(N);  // drawn cue (-1/+1)
  const xRecall = new Float32Array(N);  // recall image
  const xSmell  = new Float32Array(N);  // smell mask weights 0..1

  // Two cue paths:
  // - Gate cue: smell can mask what passes
  // - Memory cue: ignores smell (raw drawn fragments)
  const qGate = new Float32Array(N);
  const mGate = new Uint8Array(N);
  const qMem  = new Float32Array(N);
  const mMem  = new Uint8Array(N);

  for(let i=0;i<N;i++){ xGym[i] = -1; xRecall[i] = -1; xSmell[i] = 0; }

  let smellOn = false;

  // ---------- Rooms ----------
  const rooms = [
    { id:"Cnow", name:"Now",        mem:[], tat0:null, epi:"(Now) The current context tends to win.",          key:null, _ui:null },
    { id:"C10",  name:"10 years",   mem:[], tat0:null, epi:"(10 years) A younger outline comes back.",        key:null, _ui:null },
    { id:"C20",  name:"20 years",   mem:[], tat0:null, epi:"(20 years) Older context leaks in.",              key:null, _ui:null },
    { id:"C30",  name:"30 years",   mem:[], tat0:null, epi:"(30 years) Far, but still anchored somewhere.",   key:null, _ui:null },
    { id:"C40",  name:"40 years",   mem:[], tat0:null, epi:"(40 years) Smell + fragments clicks the lock.",   key:null, _ui:null },
  ];

  // write target
  let writeRoomId = "Cnow";

  function buildWriteRadios(){
    writeRadios.innerHTML = "";
    for(const r of rooms){
      const wrap = document.createElement("label");
      wrap.className = "radioItem";
      wrap.innerHTML = `
        <input type="radio" name="writeRoom" value="${r.id}" ${r.id===writeRoomId ? "checked":""}>
        <span class="label">${r.name}</span>
      `;
      wrap.querySelector("input").addEventListener("change",(ev)=>{
        writeRoomId = ev.target.value;
        txtWriteRoom.textContent = `write=${writeRoomId}`;
        updateLearnInfo();
      });
      writeRadios.appendChild(wrap);
    }
    txtWriteRoom.textContent = `write=${writeRoomId}`;
  }

  function updateLearnInfo(){
    const rr = rooms.find(x=>x.id===writeRoomId);
    txtLearnInfo.textContent = `P=${rr.mem.length}`;
  }

  buildWriteRadios();
  updateLearnInfo();

  // ---------- smell mask ----------
  function rebuildSmellMask(){
    const strength = Number(rngSmell.value);
    if(!smellOn){
      for(let i=0;i<N;i++) xSmell[i]=0;
      return;
    }
    // Smell ON: only some features "pass" (bias the gate)
    for(let y=0;y<H;y++){
      for(let x=0;x<W;x++){
        const i=y*W+x;
        const lower  = (y > 36) ? 1 : 0;
        const band   = (x > 18 && x < 46 && y > 20 && y < 30) ? 1 : 0;
        const corner = (x > 48 && y > 44) ? 1 : 0;
        const m = (lower || band || corner) ? 1 : 0;
        xSmell[i] = m * strength;
      }
    }
  }

  function updateUINumbers(){
    txtSmell.textContent = Number(rngSmell.value).toFixed(2);
    txtTheta.textContent = Number(rngTheta.value).toFixed(2);
    txtDelta.textContent = Number(rngDelta.value).toFixed(2);
    txtBeta.textContent  = String(Number(rngBeta.value)|0);
    btnSmellToggle.textContent = smellOn ? "ON" : "OFF";
  }

  // ---------- tatami helpers ----------
  function makeTatamiHotspot(ix){
    const p = new Float32Array(TN);
    for(let i=0;i<TN;i++) p[i]=0;
    p[ix]=1;
    const x=ix%TW, y=(ix/TW)|0;
    for(let dy=-1;dy<=1;dy++){
      for(let dx=-1;dx<=1;dx++){
        const xx=x+dx, yy=y+dy;
        if(xx>=0&&xx<TW&&yy>=0&&yy<TH){
          const j=yy*TW+xx;
          p[j]=Math.max(p[j], 0.45);
        }
      }
    }
    return p;
  }

  rooms.find(r=>r.id==="Cnow").tat0 = makeTatamiHotspot(4*8+4);
  rooms.find(r=>r.id==="C10").tat0  = makeTatamiHotspot(2*8+6);
  rooms.find(r=>r.id==="C20").tat0  = makeTatamiHotspot(6*8+1);
  rooms.find(r=>r.id==="C30").tat0  = makeTatamiHotspot(1*8+1);
  rooms.find(r=>r.id==="C40").tat0  = makeTatamiHotspot(6*8+2);

  // ---------- UI room bars ----------
  function buildRoomBars(){
    roomsBox.innerHTML = "";
    for(const r of rooms){
      const line = document.createElement("div");
      line.className = "roomline";

      const name = document.createElement("div");
      name.className="roomname";
      name.textContent=r.name;

      const bar = document.createElement("div");
      bar.className="bar";
      const fill = document.createElement("div");
      bar.appendChild(fill);

      const pill = document.createElement("div");
      pill.className="pill";
      pill.textContent="d=0.00 s=0.00 P=0";

      line.appendChild(name);
      line.appendChild(bar);
      line.appendChild(pill);
      roomsBox.appendChild(line);

      r._ui = { line, fill, pill };
    }
  }
  buildRoomBars();

  // ---------- rendering ----------
  function render64(ctx, arr){
    const img = ctx.createImageData(W,H);
    const d = img.data;
    for(let i=0;i<N;i++){
      const v = (arr[i]+1)*0.5;
      const c = clamp(v,0,1)*255|0;
      const j=i*4;
      d[j]=c; d[j+1]=c; d[j+2]=c; d[j+3]=255;
    }
    const off = document.createElement("canvas");
    off.width=W; off.height=H;
    off.getContext("2d").putImageData(img,0,0);

    ctx.clearRect(0,0,256,256);
    ctx.imageSmoothingEnabled=false;
    ctx.drawImage(off,0,0,256,256);
  }

  function renderGym(){ render64(cxGym, xGym); }
  function renderRecall(){ render64(cxRecall, xRecall); }

  function renderTatami(pVec){
    cxTatami.clearRect(0,0,cvTatami.width,cvTatami.height);
    const cellW=cvTatami.width/TW;
    const cellH=cvTatami.height/TH;
    for(let y=0;y<TH;y++){
      for(let x=0;x<TW;x++){
        const i=y*TW+x;
        const v=clamp(pVec[i],0,1);
        const c=(v*255)|0;
        cxTatami.fillStyle=`rgb(${c},${c},${c})`;
        cxTatami.fillRect(x*cellW,y*cellH,cellW,cellH);
        cxTatami.strokeStyle="rgba(255,255,255,.12)";
        cxTatami.strokeRect(x*cellW,y*cellH,cellW,cellH);
      }
    }
  }

  function renderSpark(spark01){
    const tmp = new Float32Array(N);
    for(let i=0;i<N;i++){
      const v = clamp(spark01[i],0,1);
      tmp[i] = v*2 - 1;
    }
    render64(cxSpark, tmp);
  }

  // ---------- draw interaction ----------
  let drawing=false;
  function canvasToGridPos(ev){
    const r=cvGym.getBoundingClientRect();
    const x=(ev.clientX-r.left)/r.width;
    const y=(ev.clientY-r.top)/r.height;
    return { gx:Math.floor(x*W), gy:Math.floor(y*H) };
  }

  function drawAt(gx,gy){
    const rad=3;
    for(let y=gy-rad;y<=gy+rad;y++){
      for(let x=gx-rad;x<=gx+rad;x++){
        if(x<0||x>=W||y<0||y>=H) continue;
        const dx=x-gx, dy=y-gy;
        if(dx*dx+dy*dy <= rad*rad){
          xGym[y*W+x] = +1;
        }
      }
    }
  }

  cvGym.addEventListener("mousedown",(ev)=>{
    drawing=true;
    const {gx,gy}=canvasToGridPos(ev);
    drawAt(gx,gy);
    renderGym();
    updateGateAndUI(false);
  });
  window.addEventListener("mouseup",()=>drawing=false);
  cvGym.addEventListener("mousemove",(ev)=>{
    if(!drawing) return;
    const {gx,gy}=canvasToGridPos(ev);
    drawAt(gx,gy);
    renderGym();
    updateGateAndUI(false);
  });

  // ---------- buildQs ----------
  function buildQs(){
    let passedGate=0, passedMem=0;

    for(let i=0;i<N;i++){
      const painted = (xGym[i] > 0);

      // mem cue: any painted pixel counts (ignores smell)
      if(painted){
        qMem[i]=+1; mMem[i]=1; passedMem++;
      }else{
        qMem[i]=0;  mMem[i]=0;
      }

      // gate cue: smell ON can block pixels
      if(!painted){
        qGate[i]=0; mGate[i]=0;
        continue;
      }
      if(smellOn && xSmell[i] <= 0){
        qGate[i]=0; mGate[i]=0;
        continue;
      }
      qGate[i]=+1; mGate[i]=1; passedGate++;
    }

    const covGate = passedGate/N;
    const covMem  = passedMem/N;
    txtCoverage.textContent = `gate ${(covGate*100).toFixed(1)}% / mem ${(covMem*100).toFixed(1)}%`;
    return { covGate, covMem };
  }

  function simGateToPattern(v){
    let num=0, den=0;
    for(let i=0;i<N;i++){
      if(mGate[i]===0) continue;
      num += qGate[i]*v[i];
      den++;
    }
    return den===0 ? -1 : num/den;
  }

  function simMemToPattern(v){
    let num=0, den=0;
    for(let i=0;i<N;i++){
      if(mMem[i]===0) continue;
      num += qMem[i]*v[i];
      den++;
    }
    return den===0 ? -1 : num/den;
  }

  // A) scoreRoomByKey (gate cue scores the room key)
  function scoreRoomByKey(room){
    if(!room.key) return -0.6;
    return simGateToPattern(room.key);
  }

  function pickTopKRooms(roomScores, K){
    const pairs = rooms.map((r,idx)=>({ r, s: roomScores[idx] }));
    pairs.sort((a,b)=>b.s-a.s);
    return pairs.slice(0, K);
  }

  // B) bestMemInRoom (memory cue scores stored memories)
  function bestMemInRoom(room){
    let best=-1e9, bestIdx=-1;
    for(let j=0;j<room.mem.length;j++){
      const m = room.mem[j];
      const s = simMemToPattern(m.v);
      if(s>best){ best=s; bestIdx=j; }
    }
    return { best, bestIdx };
  }

  function bestAcrossRooms(topPairs){
    let best=-1e9, second=-1e9;
    let win=null;
    for(const p of topPairs){
      const room = p.r;
      const roomS = p.s;
      const bm = bestMemInRoom(room);
      const memS = (bm.bestIdx>=0) ? bm.best : -0.8;
      const finalS = memS + 0.15*roomS;

      if(finalS > best){
        second = best;
        best = finalS;
        win = { room, roomS, memS, finalS, memIdx: bm.bestIdx };
      }else if(finalS > second){
        second = finalS;
      }
    }
    return { win, best, second, margin: best-second };
  }

  function updateRoomBars(roomScores, openRoom){
    const theta = Number(rngTheta.value);
    const beta  = Number(rngBeta.value);
    for(let i=0;i<rooms.length;i++){
      const r=rooms[i];
      const s=roomScores[i];
      const d=sigmoid(beta*(s-theta));
      r._ui.fill.style.width = `${Math.round(d*100)}%`;
      r._ui.pill.textContent = `d=${d.toFixed(2)} s=${s.toFixed(2)} P=${r.mem.length}`;
      r._ui.line.style.outline = (openRoom && openRoom===r) ? "2px solid rgba(200,240,255,.55)" : "none";
      r._ui.line.style.borderRadius="12px";
    }
  }

  function makeFuzzyTatamiFromTop(topPairs){
    const p = new Float32Array(TN);
    for(let t=0;t<topPairs.length;t++){
      const room = topPairs[t].r;
      const s = topPairs[t].s;
      const amp = clamp((s - (-0.2))/1.2, 0, 1) * 0.55;
      const base = room.tat0;
      for(let i=0;i<TN;i++){
        p[i] = Math.max(p[i], base[i]*amp);
      }
    }
    return p;
  }

  // Spark uses memory cue (not gate cue)
  function sparkOverlayForRoom(room){
    const out = new Float32Array(N);
    if(room.mem.length===0){
      for(let i=0;i<N;i++) out[i]=0;
      return out;
    }

    let maxv = 1e-9;
    for(const m of room.mem){
      const s = simMemToPattern(m.v);
      const a = Math.max(0, s);
      const g = m.w * a;
      if(g<=0) continue;
      for(let i=0;i<N;i++){
        if(m.v[i] > 0) out[i] += g;
      }
    }
    for(let i=0;i<N;i++) if(out[i] > maxv) maxv = out[i];
    for(let i=0;i<N;i++) out[i] = out[i] / maxv;
    return out;
  }

  function updateGateAndUI(withEpisode){
    const { covGate, covMem } = buildQs();

    const theta = Number(rngTheta.value);
    const baseDelta = Number(rngDelta.value);

    // Smell ON makes the gate a little less hesitant (demo choice)
    const delta = smellOn ? baseDelta*0.75 : baseDelta;

    const roomScores = rooms.map(r=>scoreRoomByKey(r));
    const topPairs = pickTopKRooms(roomScores, 2);
    txtTopRooms.textContent = `Top: ${topPairs.map(p=>`${p.r.id}:${p.s.toFixed(2)}`).join(" / ")}`;

    const { win, best, margin } = bestAcrossRooms(topPairs);

    // Door decision uses gate coverage (covGate)
    const open = (win && best > theta && margin > delta && covGate > 0.002);

    updateRoomBars(roomScores, open ? win.room : null);

    const tat = open ? (win.room.tat0) : makeFuzzyTatamiFromTop(topPairs);
    renderTatami(tat);

    if(open){
      renderSpark(sparkOverlayForRoom(win.room));
    }else{
      renderSpark(new Float32Array(N));
    }

    txtStatus.innerHTML =
      `covGate=${(covGate*100).toFixed(1)}% / covMem=${(covMem*100).toFixed(1)}% / smell=${smellOn?"ON":"OFF"}<br/>`+
      `winner: ${win ? `${win.room.name} (mem#${win.memIdx>=0?win.memIdx:"-"})` : "(none)"}<br/>`+
      `final=${best.toFixed(2)} / margin=${margin.toFixed(2)} / θ=${theta.toFixed(2)} Δ=${delta.toFixed(2)}<br/>`+
      `door: ${open ? "OPEN" : "CLOSED"}`;

    txtDebug.textContent =
      `writeRoomId=${writeRoomId}\n`+
      `Gate: qGate (masked by smell) -> Top2 rooms\n`+
      `Memory: qMem (unmasked) -> best memory competition\n`+
      `finalScore = memScore + 0.15*roomScore\n`+
      `open if (final>θ) AND (margin>Δ) AND (covGate>min)\n`;

    if(withEpisode){
      txtEpisode.textContent = open
        ? `${win.room.epi}\n\n`+
          `(internal) roomScore=${win.roomS.toFixed(2)} memScore=${win.memS.toFixed(2)} w=${(win.memIdx>=0?win.room.mem[win.memIdx].w:0).toFixed(2)}`
        : "Door is still closed.\nTry smell ON, tune θ/Δ, or learn more traces to create competition.";
    }

    return { open, win, topPairs, roomScores, covGate, covMem, theta, delta, best, margin };
  }

  // ---------- learn / recall ----------
  function copyGymToPattern(){
    const v = new Float32Array(N);
    for(let i=0;i<N;i++) v[i] = (xGym[i] > 0) ? +1 : -1;
    return v;
  }

  function simPatternToPattern(vA, vB){
    let num=0;
    for(let i=0;i<N;i++) num += vA[i]*vB[i];
    return num / N;
  }

  function updateRoomKeyFromMem(room){
    const P = room.mem.length;
    if(P<=0){ room.key=null; return; }
    const acc = new Float32Array(N);
    for(const m of room.mem){
      const w = m.w;
      const v = m.v;
      for(let i=0;i<N;i++) acc[i] += w * v[i];
    }
    const k = new Float32Array(N);
    for(let i=0;i<N;i++) k[i] = (acc[i] >= 0) ? +1 : -1;
    room.key = k;
  }

  function tatamiFromGym(){
    let sx=0, sy=0, cnt=0;
    for(let y=0;y<H;y++){
      for(let x=0;x<W;x++){
        const i=y*W+x;
        if(xGym[i] > 0){ sx += x; sy += y; cnt++; }
      }
    }
    if(cnt===0) return makeTatamiHotspot(4*8+4);
    const cx = sx/cnt;
    const cy = sy/cnt;
    const tx = clamp(Math.floor(cx / (W/TW)), 0, TW-1);
    const ty = clamp(Math.floor(cy / (H/TH)), 0, TH-1);
    return makeTatamiHotspot(ty*TW+tx);
  }

  function learnInto(room){
    // Room-level forgetting (keeps the demo from becoming immortal)
    for(const m of room.mem) m.w *= 0.995;

    const vNew = copyGymToPattern();

    // If it is similar, reinforce. Otherwise, append.
    const MERGE_TH = 0.75;
    let best=-1e9, bestIdx=-1;
    for(let j=0;j<room.mem.length;j++){
      const s = simPatternToPattern(vNew, room.mem[j].v);
      if(s>best){ best=s; bestIdx=j; }
    }

    if(bestIdx>=0 && best > MERGE_TH){
      room.mem[bestIdx].w = Math.min(room.mem[bestIdx].w + 0.35, 6.0);
    }else{
      room.mem.push({ v: vNew, w: 1.0 });
    }

    updateRoomKeyFromMem(room);
    room.tat0 = tatamiFromGym();
  }

  function sign3(v,thr){
    if(v>thr) return +1;
    if(v<-thr) return -1;
    return 0;
  }

  function recallLowRankFromRooms(winnerRoom, winnerMemIdx, steps){
    for(let i=0;i<N;i++) xRecall[i]=xGym[i];

    if(!winnerRoom || winnerRoom.mem.length===0 || winnerMemIdx<0){
      for(let i=0;i<N;i++) xRecall[i] = -1;
      renderRecall();
      return;
    }

    const thr=0.05;
    const tmp = new Float32Array(N);

    for(let it=0; it<steps; it++){
      tmp.fill(0);

      for(const m of winnerRoom.mem){
        const s = simMemToPattern(m.v);
        const a = Math.max(0, s);
        const g = m.w * a;
        if(g<=0) continue;

        let dot=0;
        for(let i=0;i<N;i++) dot += m.v[i] * xRecall[i];
        dot /= N;

        const scale = g * dot;
        for(let i=0;i<N;i++) tmp[i] += m.v[i] * scale;
      }

      for(let i=0;i<N;i++) xRecall[i] = sign3(tmp[i], thr);
    }

    renderRecall();
  }

  // ---------- buttons ----------
  btnClear.addEventListener("click",()=>{
    // Clears only the input drawing. Learned memories stay.
    for(let i=0;i<N;i++) xGym[i] = -1;
    renderGym();
    updateGateAndUI(true);
  });

  btnNoise.addEventListener("click",()=>{
    const p=0.08;
    for(let i=0;i<N;i++){
      if(Math.random()<p){
        xGym[i] = (xGym[i]>0) ? -1 : +1;
      }
    }
    renderGym();
    updateGateAndUI(true);
  });

  btnSmellToggle.addEventListener("click",()=>{
    smellOn = !smellOn;
    rebuildSmellMask();
    updateUINumbers();
    updateGateAndUI(true);
  });

  rngSmell.addEventListener("input",()=>{
    rebuildSmellMask();
    updateUINumbers();
    updateGateAndUI(false);
  });
  rngTheta.addEventListener("input",()=>{ updateUINumbers(); updateGateAndUI(false); });
  rngDelta.addEventListener("input",()=>{ updateUINumbers(); updateGateAndUI(false); });
  rngBeta.addEventListener("input",()=>{ updateUINumbers(); updateGateAndUI(false); });

  btnLearn.addEventListener("click",()=>{
    const room = rooms.find(r=>r.id===writeRoomId);
    learnInto(room);
    updateLearnInfo();
    buildRoomBars();
    updateGateAndUI(true);
    txtEpisode.textContent =
      `Learned into: ${room.name} (P=${room.mem.length})\n`+
      `(reinforce if similar, append if different, forget over time)`;
  });

  btnForgetRoom.addEventListener("click", ()=>{
    const room = rooms.find(r=>r.id===writeRoomId);
    room.mem = [];
    room.key = null;
    updateLearnInfo();
    buildRoomBars();
    updateGateAndUI(true);
    txtEpisode.textContent = `Forgot this room: ${room.name}`;
  });

  btnForgetAll.addEventListener("click", ()=>{
    for(const r of rooms){
      r.mem = [];
      r.key = null;
    }
    updateLearnInfo();
    buildRoomBars();
    updateGateAndUI(true);
    txtEpisode.textContent = `Forgot everything.`;
  });

  btnRecall.addEventListener("click",()=>{
    const res = updateGateAndUI(true);
    if(!res.open || !res.win){
      txtEpisode.textContent =
        "Recall triggered, but the door did not open.\n"+
        "Try smell ON, tune θ/Δ, or learn more traces to create competition.";
      for(let i=0;i<N;i++) xRecall[i] = -1;
      renderRecall();
      return;
    }

    const u = smellOn ? Number(rngSmell.value) : 0;
    const steps = 6 + Math.round(16*u);

    recallLowRankFromRooms(res.win.room, res.win.memIdx, steps);

    txtEpisode.textContent =
      `${res.win.room.epi}\n\n`+
      `Top2: ${res.topPairs.map(p=>`${p.r.id}:${p.s.toFixed(2)}`).join(" / ")}\n`+
      `Final winner: ${res.win.room.id} mem#${res.win.memIdx} (final=${res.win.finalS.toFixed(2)})`;
  });

  // ---------- init ----------
  updateUINumbers();
  rebuildSmellMask();
  renderGym();
  renderRecall();
  renderTatami(new Float32Array(TN));
  renderSpark(new Float32Array(N));
  updateGateAndUI(true);

  /* =========================================================
  Camera integration (MediaPipe Tasks HandLandmarker)
  - No layout impact (video/canvas hidden)
  - Default camera starts even if no selection
  - Exposure slider acts as software brightness on an offscreen canvas
  - Finger motion draws a cue line into xGym
  - Stop motion triggers auto recall
  ========================================================= */

  const btnStartCam = document.getElementById("btnStartCam");
  const btnStopCam  = document.getElementById("btnStopCam");
  const selCamera   = document.getElementById("selCamera");
  const rngExposure = document.getElementById("rngExposure");
  const txtExposure = document.getElementById("txtExposure");
  const txtCamState = document.getElementById("txtCamState");

  const videoEl = document.getElementById("webcam");
  const overlayEl = document.getElementById("overlayCanvas");
  const overlayCtx = overlayEl.getContext("2d");

  // offscreen preprocessing canvas (brightness/exposure)
  const preCv = document.createElement("canvas");
  preCv.width = 256; preCv.height = 256;
  const preCx = preCv.getContext("2d");

  let mp = null;               // module imports
  let handLandmarker = null;
  let drawingUtils = null;
  let stream = null;
  let running = false;
  let lastT = -1;

  let prevTip = null;
  let stopTimer = null;
  const MOVE_THRESH = 0.020;
  const STOP_DELAY = 600;

  function setCamState(s){
    txtCamState.textContent = s;
  }

  function uiExposure(){
    txtExposure.textContent = Number(rngExposure.value).toFixed(2);
  }
  rngExposure.addEventListener("input", uiExposure);
  uiExposure();

  async function populateCameras(){
    try{
      const devices = await navigator.mediaDevices.enumerateDevices();
      const keep = selCamera.value;
      selCamera.innerHTML = '<option value="">Default camera</option>';
      for(const d of devices){
        if(d.kind !== "videoinput") continue;
        const opt = document.createElement("option");
        opt.value = d.deviceId;
        opt.textContent = d.label || "Camera";
        selCamera.appendChild(opt);
      }
      // restore selection if still available
      for(const o of selCamera.options){
        if(o.value === keep){ selCamera.value = keep; break; }
      }
    }catch(e){
      console.error("enumerateDevices failed:", e);
    }
  }
  populateCameras();

  async function initMediaPipe(){
    if(handLandmarker) return;

    setCamState("LOADING");

    // dynamic import: works on localhost http(s)
    mp = await import("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14");

    const { HandLandmarker, FilesetResolver, DrawingUtils } = mp;

    const vision = await FilesetResolver.forVisionTasks(
      "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/wasm"
    );

    handLandmarker = await HandLandmarker.createFromOptions(vision, {
      baseOptions: {
        modelAssetPath:
        "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task"
      },
      runningMode: "VIDEO",
      numHands: 1,
      minHandDetectionConfidence: 0.5,
      minTrackingConfidence: 0.5
    });

    drawingUtils = new DrawingUtils(overlayCtx);

    setCamState("READY");
  }

  async function startCamera(){
    try{
      await initMediaPipe();

      const deviceId = selCamera.value; // may be empty (default camera)
      if(stream){
        stream.getTracks().forEach(t=>t.stop());
        stream = null;
      }

      // ----------------------------------------------------------
      // Robust camera acquisition for wide device compatibility
      // - Avoid fixed resolutions (cheap cameras often fail)
      // - Try default camera first
      // - If a specific device is selected, try it but keep fallback
      // - Always normalize later via preCv (256x256)
      // ----------------------------------------------------------

      // 1) Most compatible: any available camera
      try{
        stream = await navigator.mediaDevices.getUserMedia({ video:true, audio:false });
      }catch(e0){
        console.warn("getUserMedia default failed:", e0);

        // 2) Try with ideal resolution (not exact)
        stream = await navigator.mediaDevices.getUserMedia({
          video: {
            width:  { ideal: 640 },
            height: { ideal: 480 },
            frameRate: { ideal: 30 }
          },
          audio: false
        });
      }

      // 3) If selection exists, attempt explicit deviceId (with fallback)
      if(deviceId){
        try{
          const byId = {
            video: {
              deviceId: { exact: deviceId },
              width:  { ideal: 640 },
              height: { ideal: 480 },
              frameRate: { ideal: 30 }
            },
            audio: false
          };

          // reopen stream with selected device
          stream.getTracks().forEach(t=>t.stop());
          stream = await navigator.mediaDevices.getUserMedia(byId);

        }catch(e1){
          console.warn("getUserMedia by deviceId failed, fallback to default:", e1);

          // fallback again to default camera
          stream = await navigator.mediaDevices.getUserMedia({ video:true, audio:false });
        }
      }

      videoEl.srcObject = stream;
      await videoEl.play();

      // after permission, labels usually appear
      await populateCameras();

      running = true;
      setCamState("ON");

      lastT = -1;
      prevTip = null;
      if(stopTimer){ clearTimeout(stopTimer); stopTimer=null; }

      requestAnimationFrame(loop);
    }catch(e){
      console.error("Camera start failed:", e);
      alert(e.name + ": " + e.message);
      setCamState("OFF");
      running = false;
    }
  }

  function stopCamera(){
    running = false;
    if(stopTimer){ clearTimeout(stopTimer); stopTimer=null; }
    prevTip = null;

    if(stream){
      stream.getTracks().forEach(t=>t.stop());
      stream = null;
    }
    videoEl.srcObject = null;

    setCamState("OFF");
  }

  btnStartCam.addEventListener("click", startCamera);
  btnStopCam.addEventListener("click", stopCamera);

  function drawLineOnCue(ax, ay, bx, by){
    const dx = bx-ax, dy = by-ay;
    const dist = Math.sqrt(dx*dx + dy*dy);
    const steps = Math.max(1, Math.floor(dist*5));
    for(let s=0; s<=steps; s++){
      const px = Math.floor(ax + dx*s/steps);
      const py = Math.floor(ay + dy*s/steps);
      if(px>=0 && px<64 && py>=0 && py<64){
        xGym[py*64 + px] = 1;
      }
    }
  }

  function loop(ts){
    if(!running || !handLandmarker || !videoEl || videoEl.readyState < 2){
      if(running) requestAnimationFrame(loop);
      return;
    }

    // throttle on video time
    if(videoEl.currentTime !== lastT){
      lastT = videoEl.currentTime;

      // preprocess with exposure (software brightness)
      const exp = Number(rngExposure.value);
      preCx.save();
      preCx.clearRect(0,0,256,256);
      preCx.filter = `brightness(${exp})`;
      preCx.drawImage(videoEl, 0,0,256,256);
      preCx.restore();

      // optional overlay drawing (kept hidden)
      overlayCtx.clearRect(0,0,256,256);
      overlayCtx.drawImage(preCv,0,0,256,256);

      const res = handLandmarker.detectForVideo(preCv, performance.now());

      if(res && res.landmarks && res.landmarks.length > 0){
        const lm = res.landmarks[0];

        // internal debug rendering (hidden canvas)
        try{
          drawingUtils.drawLandmarks(lm, {color:"#00FF88", lineWidth:2});
        }catch(_){}

        const tip = lm[8]; // index finger tip

        if(tip){
          const gx = tip.x * 64;
          const gy = tip.y * 64;

          if(prevTip){
            drawLineOnCue(prevTip.x, prevTip.y, gx, gy);

            const dx = gx - prevTip.x;
            const dy = gy - prevTip.y;
            const dist = Math.sqrt(dx*dx + dy*dy);

            // reflect cue immediately
            renderGym();
            updateGateAndUI(false);

            if(dist < MOVE_THRESH){
              if(!stopTimer){
                stopTimer = setTimeout(()=>{
                  // auto recall
                  btnRecall.click();
                  prevTip = null;
                  stopTimer = null;
                }, STOP_DELAY);
              }
            }else{
              if(stopTimer){ clearTimeout(stopTimer); stopTimer=null; }
            }
          }

          prevTip = { x: gx, y: gy };
        }else{
          prevTip = null;
          if(stopTimer){ clearTimeout(stopTimer); stopTimer=null; }
        }

      }else{
        prevTip = null;
        if(stopTimer){ clearTimeout(stopTimer); stopTimer=null; }
      }
    }

    requestAnimationFrame(loop);
  }

})();
</script>
</body>
</html>
